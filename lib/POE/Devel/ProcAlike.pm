# Declare our package
package POE::Devel::ProcAlike;
use strict; use warnings;

# Initialize our version
use vars qw( $VERSION );
$VERSION = '0.01';

# Import what we need from the POE namespace
use POE;
use POE::Component::Fuse;
use base 'POE::Session::AttributeBased';

# load our modules to manage the filesystem
use Filesys::Virtual::Async::Dispatcher;
use POE::Devel::ProcAlike::Kernel;

# starts the component!
sub spawn {
	my $class = shift;

	# The options hash
	my %opt;

	# Support passing in a hash ref or a regular hash
	if ( ( @_ & 1 ) and ref $_[0] and ref( $_[0] ) eq 'HASH' ) {
		%opt = %{ $_[0] };
	} else {
		# Sanity checking
		if ( @_ & 1 ) {
			warn __PACKAGE__ . ' requires an even number of options passed to spawn()';
			return 0;
		}

		%opt = @_;
	}

	# lowercase keys
	%opt = map { lc($_) => $opt{$_} } keys %opt;

	# Get the session alias
	if ( ! exists $opt{'alias'} or ! defined $opt{'alias'} ) {
		if ( DEBUG ) {
			warn 'Using default ALIAS = procalike';
		}

		# Set the default
		$opt{'alias'} = 'procalike';
	} else {
		# TODO validate for sanity
	}

	# setup the FUSE mount options
	if ( ! exists $opt{'fuseopts'} or ! defined $opt{'fuseopts'} ) {
		if ( DEBUG ) {
			warn 'Using default FUSEOPTS = undef';
		}

		# Set the default
		$opt{'fuseopts'} = undef;
	} else {
		# TODO validate for sanity
	}

	# Create our session
	POE::Session->create(
		__PACKAGE__->inline_states(),
		'heap'	=>	{
			'ALIAS'		=> $opt{'alias'},
			'FUSEOPTS'	=> $opt{'fuseopts'},
		},
	);

	# return success
	return 1;
}

# This starts the component
sub _start : State {
	if ( DEBUG ) {
		warn 'Starting alias "' . $_[HEAP]->{'ALIAS'} . '"';
	}

	# Set up the alias for ourself
	$_[KERNEL]->alias_set( $_[HEAP]->{'ALIAS'} );

	return;
}

# POE Handlers
sub _stop : State {
	if ( DEBUG ) {
		warn 'Stopping alias "' . $_[HEAP]->{'ALIAS'} . '"';
	}

	# FIXME tell poco-fuse to shutdown?

	return;
}

1;
__END__
=head1 NAME

POE::Devel::ProcAlike - Exposing the guts of POE via FUSE

=head1 SYNOPSIS

	#!/usr/bin/perl
	use strict; use warnings;
	use POE::Devel::ProcAlike;
	use POE;

	# load the FUSE stuff
	POE::Devel::ProcAlike->spawn();

	# create our own "fake" session
	POE::Session->spawn(
		'inline_states'	=> {
			'_start'	=> sub {
				$_[KERNEL]->alias_set( 'foo' );
				$_[KERNEL]->yield( 'timer' );
			},
			'timer'		=> sub {
				$_[KERNEL]->delay_set( 'timer' => 60 );
			}
		},
		'heap'		=> {
			'fakedata'	=> 1,
			'oomph'		=> 'haha',
		},
	);

	# run the kernel!
	POE::Kernel->run();

=head1 ABSTRACT

Using this module will enable you to asynchronously process FUSE requests from the kernel in POE. Think of
this module as a simple wrapper around L<Fuse> to POEify it.

=head1 DESCRIPTION

This module allows you to use FUSE filesystems in POE. Basically, it is a wrapper around L<Fuse> and exposes
it's API via events. Furthermore, you can use L<Filesys::Virtual> to handle the filesystem.

The standard way to use this module is to do this:

	use POE;
	use POE::Component::Fuse;

	POE::Component::Fuse->spawn( ... );

	POE::Session->create( ... );

	POE::Kernel->run();

Naturally, the best way to quickly get up to speed is to study other implementations of FUSE to see what
they have done. Furthermore, please look at the scripts in the examples/ directory in the tarball!

=head2 Starting Fuse

To start Fuse, just call it's spawn method:

	POE::Component::Fuse->spawn( ... );

This method will return failure on errors or return success.

NOTE: The act of starting/stopping PoCo-Fuse fires off _child events, read the POE documentation on
what to do with them :)

This constructor accepts either a hashref or a hash, valid options are:

=head3 alias

This sets the session alias in POE.

The default is: "fuse"

=head3 mount

This sets the mountpoint for FUSE.

If this mountpoint doesn't exist ( and the "mkdir" option isn't set ) spawn() will return failure.

The default is: "/tmp/poefuse"

=head3 mountoptions

This passes the options to FUSE for mounting.

NOTE: this is a comma-separated string!

The default is: undef

=head3 mkdir

If true, PoCo-Fuse will attempt to mkdir the mountpoint if it doesn't exist.

If the mkdir attempt fails, spawn() will return failure.

The default is: false

=head3 umount

If true, PoCo-Fuse will attempt to umount the filesystem on exit/shutdown.

This basically calls "fusermount -u -z $mountpoint"

WARNING: This is not exactly portable and is in the testing stage. Feedback would be much appreciated!

The default is: false

=head3 prefix

The prefix for all events generated by this module when using the "session" method.

The default is: "fuse_"

=head3 session

The session to send all FUSE events to. Used in conjunction with the "prefix" option, you can control
where the events arrive.

If this option is missing ( or POE is not running ) and "vfilesys" isn't enabled spawn() will return failure.

NOTE: You cannot use this and "vfilesys" at the same time! PoCo-Fuse will pick vfilesys over this!

The default is: calling session ( if POE is running )

=head3 vfilesys

The L<Filesys::Virtual> object to use as our filesystem. PoCo-Fuse will proceed to use L<Fuse::Filesys::Virtual>
to wrap around it and process the events internally.

Furthermore, you can also use L<Filesys::Virtual::Async> subclasses, this module understands their callback API
and will process it properly!

If this option is missing and "session" isn't enabled spawn() will return failure.

NOTE: You cannot use this and "session" at the same time! PoCo-Fuse will pick this over session!

Compatibility has not been tested with all Filesys::Virtual::XYZ subclasses, so please let me know if some isn't
working properly!

The default is: not used

=head2 Commands

There is only one command you can use, because this module does nothing except process FUSE events.

=head3 shutdown

Tells this module to kill the FUSE mount and terminates the session. Due to the semantics of FUSE, this
will often result in a wedged filesystem. You would need to either umount it manually ( via "fusermount -u $mount" )
or by enabling the "umount" option.

=head2 Events

If you aren't using the Filesys::Virtual interface, the FUSE api will be exposed to you in it's glory via
events to your session. You can process them, and send the data back via the supplied postback. All the arguments
are identical to the one in L<Fuse> so please take a good look at that module for more information!

The only place where this differs is the additional arguments. All events will receive 2 extra arguments in front
of the standard FUSE args. They are the postback and context info. The postback is self-explanatory, you
supply the return data to it and it'll fire an event back to PoCo-Fuse for processing. The context is the
calling context received from FUSE. It is a hashref with the 3 keys in it: uid, gid, pid. It is received via
the fuse_get_context() sub from L<Fuse>.

Remember that the events are the fuse methods with the prefix tacked on to them. A typical FUSE handler would
look something like the example below. ( it is sugared via POE::Session::AttributeBased hah )

	sub fuse_getdir : State {
		my( $postback, $context, $path ) = @_[ ARG0 .. ARG2 ];

		# somehow get our data, we fake it here for instructional reasons
		$postback->( 'foo', 'bar', 0 );
		return;
	}

Again, pretty please read the L<Fuse> documentation for all the events you can receive. Here's the list
as of Fuse v0.09: getattr readlink getdir mknod mkdir unlink rmdir symlink rename link chmod chown truncate
utime open read write statfs flush release fsync setxattr getxattr listxattr removexattr.

=head3 CLOSED

This is a special event sent to the session notifying it of component shutdown. As usual, it will be prefixed by the
prefix set in the options. If you are using the vfilesys option, this will not be sent anywhere.

The event handler will get one argument, the error string. If you shut down the component, it will be "shutdown",
otherwise it will contain some error string. A sample handler is below.

	sub fuse_CLOSED : State {
		my $error = $_[ARG0];
		if ( $error ne 'shutdown' ) {
			print "AIEE: $error\n";

			# do some actions like emailing the sysadmin, restarting the component, etc...
		} else {
			# we told it to shutdown, so what do we want to do next?
		}

		return;
	}

=head1 EXPORT

None.

=head1 SEE ALSO

L<POE>

L<Fuse>

L<Filesys::Virtual::Async>

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc POE::Devel::ProcAlike

=head2 Websites

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/POE-Devel-ProcAlike>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/POE-Devel-ProcAlike>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=POE-Devel-ProcAlike>

=item * Search CPAN

L<http://search.cpan.org/dist/POE-Devel-ProcAlike>

=back

=head2 Bugs

Please report any bugs or feature requests to C<bug-poe-devel-procalike at rt.cpan.org>, or through
the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=POE-Devel-ProcAlike>.  I will be
notified, and then you'll automatically be notified of progress on your bug as I make changes.

=head1 AUTHOR

Apocalypse E<lt>apocal@cpan.orgE<gt>

Props goes to xantus who got me motivated to write this :)

=head1 COPYRIGHT AND LICENSE

Copyright 2009 by Apocalypse

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
